#!/usr/bin/env bash

# Bash strict mode (https://github.com/alphabetum/bash-boilerplate)
set -eEuo pipefail
trap 'echo "Aborting (errexit line $LINENO). Exit code: $?" >&2' ERR
IFS=$'\n\t'

add_bittorrent_incoming() {
	sudo iptables -A INPUT -p tcp -m tcp --dport 8999 -j ACCEPT
	sudo iptables -A INPUT -p udp -m udp --dport 8999 -j ACCEPT
}

add_bittorrent_rules() {
	sudo iptables -A OUTPUT -p tcp -m tcp --dport 6969 -j ACCEPT
	sudo iptables -A OUTPUT -p tcp -m tcp --dport 8999 -j ACCEPT
	sudo iptables -A OUTPUT -p tcp -m tcp --dport 51413 -j ACCEPT
	sudo iptables -A OUTPUT -p udp -m udp --dport 6969 -j ACCEPT
	sudo iptables -A OUTPUT -p udp -m udp --dport 8999 -j ACCEPT
	sudo iptables -A OUTPUT -p udp -m udp --dport 51413 -j ACCEPT

	# Allow incoming bittorrent connections?
	while true; do
		read -r -p "Allow BitTorrent inbound? [y/N]: " -n 1 mc
		printf '\n'
		case $mc in
			[Yy]* ) add_bittorrent_incoming; break;;
			[Nn]* ) break;;
			"" ) break;;
		esac
	done
}

add_minecraft_rules() {
	sudo iptables -A OUTPUT -p tcp -m tcp --dport 25565 -j ACCEPT
	sudo iptables -A OUTPUT -p tcp -m tcp --dport 27094 -j ACCEPT
}

add_printing_rules() {
	sudo iptables -A OUTPUT -d "$INTRANET" -p tcp -m tcp --dport 161 -j ACCEPT
	sudo iptables -A OUTPUT -d "$INTRANET" -p tcp -m tcp --dport 515 -j ACCEPT
	sudo iptables -A OUTPUT -d "$INTRANET" -p tcp -m tcp --dport 631 -j ACCEPT
}

add_openvpn_rules() {
	sudo iptables -A OUTPUT -p tcp -m tcp --dport 1194 -j ACCEPT
	sudo iptables -A OUTPUT -p udp -m udp --dport 1194 -j ACCEPT
}

add_workstation_rules() {

	# Allow ping to intranet
	sudo iptables -A INPUT -s "$INTRANET" -p icmp --icmp-type 0 -j ACCEPT  # echo reply
	sudo iptables -A INPUT -s "$INTRANET" -p icmp --icmp-type 3 -j ACCEPT  # unreachable
	sudo iptables -A INPUT -s "$INTRANET" -p icmp --icmp-type 11 -j ACCEPT # time exceeded
	sudo iptables -A INPUT -s "$INTRANET" -p icmp --icmp-type 12 -j ACCEPT # parameter problem
	sudo iptables -A OUTPUT -s "$INTRANET" -p icmp --icmp-type 8 -j ACCEPT # echo request

	# Allow needed workstation outbound access
	sudo iptables -A OUTPUT -p tcp -m tcp --dport 22 -j ACCEPT # SSH
	sudo iptables -A OUTPUT -p tcp -m tcp --dport 43 -j ACCEPT # WHOIS
	sudo iptables -A OUTPUT -p tcp -m tcp --dport 873 -j ACCEPT # RSYNC
	sudo iptables -A OUTPUT -p tcp -m tcp --dport 6667 -j ACCEPT # IRC

	# Allow printing to intranet?
	while true; do
		read -r -p "Does this computer use network printers? [y/N]: " -n 1 np
		printf '\n'
		case $np in
			[Yy]* ) add_printing_rules; break;;
			[Nn]* ) break;;
			"" ) break;;
		esac
	done

	# Allow Minecraft outbound?
	while true; do
		read -r -p "Is this computer used to play Minecraft? [y/N]: " -n 1 mc
		printf '\n'
		case $mc in
			[Yy]* ) add_minecraft_rules; break;;
			[Nn]* ) break;;
			"" ) break;;
		esac
	done

	# Allow ProxMox outbound?
	while true; do
		read -r -p "Is this computer used to access ProxMox? [y/N]: " -n 1 ov
		printf '\n'
		case $ov in
			[Yy]* ) sudo iptables -A OUTPUT -p tcp -m tcp --dport 8006 -j \
				ACCEPT; break;;
			[Nn]* ) break;;
			"" ) break;;
		esac
	done

	# Allow vSphere outbound?
	while true; do
		read -r -p "Is this computer used to access vSphere? [y/N]: " -n 1 vs
		printf '\n'
		case $vs in
			[Yy]* ) sudo iptables -A OUTPUT -p tcp -m tcp --dport 9443 -j \
				ACCEPT; break;;
			[Nn]* ) break;;
			"" ) break;;
		esac
	done
}

save_permanent_iptables() {

	# On an Arch machine:
	if [ -x "$(command -v pacman)" ] && \
		[ -x "$(command -v iptables-save)" ]; then
		sudo iptables-save | sudo tee /etc/iptables/iptables.rules >/dev/null

	# On a CentOS machine:
	elif [ -x "$(command -v yum)" ] && \
		sudo yum list installed iptables-services >/dev/null 2>&1 ; then
		sudo service iptables save
	
	# On a Debian machine:
	elif [ -x "$(apt)" ] && dpkg -s iptables-persistent >/dev/null 2>&1; then
		sudo dpkg-reconfigure -y iptables-persistent
	
	# Otherwise, fail:
	else
		# Warn about non-persistence
		printf '\e[1;31mWARNING:\e[0m'
		printf ' The applied configuration is NOT PERMANENT across reboots. Please\n'
		printf "    consult your distribution's documentation to determine how best to\\n"
		printf '    persist these rules. Suggested tools include iptables-persistent,\n'
		printf '    iptables-save, or iptables-services.\n'
	fi

}

main() {
	# Sanity check
	if [ ! -x "$(command -v iptables)" ]; then
		printf 'Do you have iptables installed?\n'
		exit 127
	fi

	# firewalld sanity check
	if [ -x "$(command -v firewall-cmd)" ]; then
		while true; do
			printf 'firewalld conflicts with these settings.\n'
			read -r -p "Continue with iptables? [y/N]: " -n 1 yn
			printf '\n'
			case $yn in
				[Yy]* ) break;;
				[Nn]* ) exit;;
				"" ) exit;;
			esac
		done
	fi

	# nftables sanity check
	if [ -x "$(command -v nft)" ]; then
		while true; do
			printf 'You have nftables installed. It supercedes iptables.\n'
			read -r -p "Continue with iptables? [y/N]: " -n 1 yn
			printf '\n'
			case $yn in
				[Yy]* ) break;;
				[Nn]* ) exit;;
				"" ) exit;;
			esac
		done
	fi

	# sudo check
	if [ ! -x "$(command -v sudo)" ]; then
		printf '%s\n' "This script requires sudo." >&2
		exit 127
	fi

	# Don't run with sudo! Need to preserve $SSH_CLIENT in some situations
	if (( "$(id -u)" == 0 )) && [ ! -z "$SUDO_COMMAND" ]; then
		printf 'Do not run this as root (sudo); it invokes sudo as required.\n'
		exit 1
	fi

	# Find necessary information
	local IFACE
	IFACE="$(ip route | grep default | awk '{print $5}')"
	local INTRANET
	INTRANET="$(ip addr | grep "$IFACE" | awk 'FNR==2{print $2}')" # Intranet
	local INTRANET_ADDR
	INTRANET_ADDR="$(printf '%s' "$INTRANET" | awk -F/ '{print $1}')"
	if [ ! -z "${SSH_CLIENT+x}" ]; then
		local SSH_ADDR
		SSH_ADDR="$(echo "$SSH_CLIENT" | cut -d' ' -f1)"
	fi

	# Ensure iptables service is running
	if [ -x "$(command -v systemctl)" ]; then
		sudo systemctl restart iptables
	fi

	# Clear initial rules (set all policies to ACCEPT and delete extra chains)
	sudo iptables -P INPUT ACCEPT
    sudo iptables -P FORWARD ACCEPT
    sudo iptables -P OUTPUT ACCEPT
	sudo iptables -F
	sudo iptables -X

	# The "BASE" chain will be used to hold rules applied to all other chains
	sudo iptables -N BASE
	sudo iptables -A INPUT -j BASE
	sudo iptables -A FORWARD -j BASE
	sudo iptables -A OUTPUT -j BASE

	# Drop invalid connections
	sudo iptables -A BASE -m state --state INVALID -j DROP

	# Allow established connections
	sudo iptables -A BASE -m state --state ESTABLISHED,RELATED -j ACCEPT

	# Allow loopback in and out
	sudo iptables -A BASE -i lo -j ACCEPT
	sudo iptables -A BASE -s 127.0.0.0/8 -d 127.0.0.0/8 -j ACCEPT

	# Jump back after the base chain
	sudo iptables -A BASE -j RETURN

	# Anti-lockout rule (allow SSH from current connection)
	[ -z "${SSH_ADDR+x}" ] || sudo iptables -A INPUT -s "$SSH_ADDR" -p tcp \
		-m tcp --dport 22 -j ACCEPT

	# Set default policy for all chains to DROP
	sudo iptables -P INPUT DROP
	sudo iptables -P FORWARD DROP
	sudo iptables -P OUTPUT DROP

	# Also drop IPv6
	if [ -x "$(command -v ip6tables)" ]; then
		sudo ip6tables -F
		sudo ip6tables -P INPUT DROP
		sudo ip6tables -P FORWARD DROP
		sudo ip6tables -P OUTPUT DROP
	fi

	# Prevent host spoofing
	sudo iptables -A INPUT -s "$INTRANET_ADDR" -j DROP
	sudo iptables -A FORWARD -s "$INTRANET_ADDR" -j DROP
	sudo iptables -A FORWARD -d "$INTRANET_ADDR" -j DROP
	sudo iptables -A OUTPUT -d "$INTRANET_ADDR" -j DROP

	# Allow DHCP from intranet for faster renewals
	sudo iptables -A INPUT -s "$INTRANET" -p udp -m udp --sport 67 -m udp \
		--dport 68 -j ACCEPT

	# Allow mDNS from intranet for zeroconf
	sudo iptables -A INPUT -s "$INTRANET" -p udp -m udp --dport 5353 -j ACCEPT

	# Allow ping from intranet
	sudo iptables -A INPUT -s "$INTRANET" -p icmp --icmp-type 8 -j ACCEPT   # echo request
	sudo iptables -A OUTPUT -s "$INTRANET" -p icmp --icmp-type 0 -j ACCEPT  # echo reply

	# Uncomment the lines below as needed to make services available
	# sudo iptables -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT # SSH
	# sudo iptables -A INPUT -p udp -m udp --dport 53 -j ACCEPT # SSH
	# sudo iptables -A INPUT -p tcp -m tcp --dport 80 -j ACCEPT # HTTP
	# sudo iptables -A INPUT -p tcp -m tcp --dport 443 -j ACCEPT # HTTPS
	# sudo iptables -A INPUT -p udp -m udp --dport 443 -j ACCEPT # HTTP/2
	# sudo iptables -A INPUT -p tcp -m tcp --dport 25565 -j ACCEPT # Minecraft
	# sudo iptables -A INPUT -p tcp -m tcp --dport 8123 -j ACCEPT # Dynmap

	# Allow required services outbound (TCP)
	sudo iptables -A OUTPUT -p tcp -m tcp --dport 80 -j ACCEPT # HTTP
	sudo iptables -A OUTPUT -p tcp -m tcp --dport 443 -j ACCEPT # HTTPS

	# Allow required services outbound (UDP)
	sudo iptables -A OUTPUT -p udp -m udp --dport 53 -j ACCEPT # DNS
	sudo iptables -A OUTPUT -p udp -m udp --dport 443 -j ACCEPT # HTTP/2
	sudo iptables -A OUTPUT -p udp -m udp --dport 123 -j ACCEPT # NTP

	# Allow BitTorrent?
	while true; do
		read -r -p "Allow BitTorrent? [y/N]: " -n 1 bt
		printf '\n'
		case $bt in
			[Yy]* ) add_bittorrent_rules; break;;
			[Nn]* ) break;;
			"" ) break;;
		esac
	done

	# Allow OpenVPN outbound?
	while true; do
		read -r -p "Does this computer use OpenVPN? [y/N]: " -n 1 ov
		printf '\n'
		case $ov in
			[Yy]* ) add_openvpn_rules; break;;
			[Nn]* ) break;;
			"" ) break;;
		esac
	done

	# Workstation?
	while true; do
		read -r -p "Is this machine a workstation? [y/N]: " -n 1 wk
		printf '\n'
		case $wk in
			[Yy]* ) add_workstation_rules; break;;
			[Nn]* ) break;;
			"" ) break;;
		esac
	done

	# Show the result
	printf '\n\e[1;32m%s\e[0m\n\n' "IPTables rules implemented:"
	sudo iptables -L
	printf '\n'

	# Make rules persistent
	while true; do
		read -r -p "Save rules persistently? [y/N]: " -n 1 yn
		printf '\n'
		case $yn in
			[Yy]* ) save_permanent_iptables; break;;
			[Nn]* ) break;;
			"" ) break;;
		esac
	done

	# Start iptables at boot
	if [ -x "$(command -v systemctl)" ]; then
		while true; do
			read -r -p "Start iptables at boot? [y/N]: " -n 1 yn
			printf '\n'
			case $yn in
				[Yy]* ) sudo systemctl enable iptables; break;;
				[Nn]* ) break;;
				"" ) break;;
			esac
		done
	fi
}

main "$@"
