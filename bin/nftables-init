#!/usr/bin/env bash

# Bash strict mode (https://github.com/alphabetum/bash-boilerplate)
set -eEuo pipefail
trap 'echo "Aborting (errexit line $LINENO). Exit code: $?" >&2' ERR

usage() {
	printf 'Usage: %s\n' "$(basename "$0")" >&2
	printf ' -h --help : display this message\n' >&2
	exit
}

user_confirm() {
	while true; do
		read -r -p "$1 [y/N]: " -n 1 yn
		printf '\n'
		case $yn in
			[Yy]* ) eval "$2"; break;;
			[Nn]* ) break;;
			"" ) break;;
		esac
	done
}

add_ip_chain() {
	sudo nft add chain ip filter "$@"
}

add_ip_rule() {
	sudo nft add rule ip filter "$@"
}

add_ip6_chain() {
	sudo nft add chain ip6 filter "$@"
}

add_ip6_rule() {
	sudo nft add rule ip6 filter "$@"
}

add_bittorrent_incoming() {
	add_ip_rule input tcp dport 8999 accept
	add_ip_rule input udp dport 8999 accept
}

add_bittorrent_rules() {
	add_ip_rule output tcp dport \{ 6969, 8999, 51413 \} accept
	add_ip_rule output udp dport \{ 6969, 8999, 51413 \} accept
	user_confirm 'Allow BitTorrent inbound?' add_bittorrent_incoming
}

add_printing_rules() {
	# Allow printing to intranet
	# add_ip_rule output ip daddr "$INTRANET" tcp dport snmp accept
	# add_ip_rule output ip daddr "$INTRANET" tcp dport 515 accept
	add_ip_rule output ip daddr "$INTRANET" tcp dport ipp accept
}

add_openvpn_rules() {
	add_ip_rule output tcp dport openvpn accept
	add_ip_rule output udp dport openvpn accept
}

add_workstation_rules() {

	# Allow ping to intranet
	add_ip_rule input ip protocol icmp ip saddr "$INTRANET" icmp type \
		\{ echo-reply, time-exceeded, parameter-problem, \
		destination-unreachable \} accept
	add_ip_rule output ip protocol icmp ip saddr "$INTRANET" icmp type \
		echo-request accept

	# Allow needed workstation outbound access
	# I use 59999 for mosh
	add_ip_rule output tcp dport \{ ircd, 6697, rsync, ssh, whois \} accept
	add_ip_rule output udp dport 59999 accept
	user_confirm 'Does this computer use network printers?' add_printing_rules
	user_confirm 'Is this computer used to play Minecraft?' \
		'add_ip_rule output tcp dport { 25565, 27094 } accept'
	user_confirm 'Is this computer used to access ProxMox?' \
		'add_ip_rule output tcp dport 8006 accept'
	user_confirm 'Is this computer used to access Remote Desktop (RDP)?' \
		'add_ip_rule output tcp dport 3389 accept'
	user_confirm 'Is this computer used to access vSphere?' \
		'add_ip_rule output tcp dport 9443 accept'
}

save_permanent_nftables() {
	sudo cp /etc/nftables.conf /etc/nftables.conf.bak
	printf '#!/usr/bin/nft -f\n\n' | sudo tee /etc/nftables.conf >/dev/null
	sudo nft list ruleset | sudo tee -a /etc/nftables.conf >/dev/null
	printf 'Configuration saved.\n'
}

main() {
	# Sanity check
	if [ ! -x "$(command -v nft)" ]; then
		printf 'Do you have nftables installed?\n' >&2
		exit 127
	fi

	# Sudo check
	if [ ! -x "$(command -v sudo)" ]; then
		printf 'This script requires sudo.\n' >&2
		exit 127
	fi

	# Don't run with sudo! Need to preserve $SSH_CLIENT in some situations
	if (( "$(id -u)" == 0 )) && [ -n "$SUDO_COMMAND" ]; then
		printf 'Do not run this as root (sudo); it invokes sudo as required.\n'
		exit 1
	fi

	# Find necessary information
	local IFACE
	IFACE="$(ip route | grep default | awk '{print $5}')" # Main interface
	local INTRANET
	INTRANET="$(ip addr | grep "$IFACE" | awk 'FNR==2{print $2}')" # Intranet
	local INTRANET_ADDR
	INTRANET_ADDR="$(printf '%s' "$INTRANET" | awk -F/ '{print $1}')"
	if [ -n "${SSH_CLIENT+x}" ]; then
		local SSH_ADDR
		SSH_ADDR="$(echo "$SSH_CLIENT" | cut -d' ' -f1)"
	fi

	# Ensure nftables service is running
	if [ -x "$(command -v systemctl)" ]; then
		sudo systemctl restart nftables
	fi

	# Clear initial rules (set all policies to ACCEPT and delete extra chains)
	sudo nft flush ruleset
	sudo nft add table ip filter
	add_ip_chain input \{ type filter hook input priority 0\; \}
	add_ip_chain forward \{ type filter hook forward priority 0\; \}
	add_ip_chain output \{ type filter hook output priority 0\; \}

	# The "base" chain will be used to hold rules applied to all other chains
	add_ip_chain base
	add_ip_rule input jump base
	add_ip_rule forward jump base
	add_ip_rule output jump base

	# Drop invalid connections
	add_ip_rule base ct state invalid drop

	# Allow established connections
	add_ip_rule base ct state \{ established, related \} accept

	# Allow loopback in and out to itself
	add_ip_rule base meta iif lo oif lo accept
	add_ip_rule base ip saddr 127.0.0.0/8 ip daddr 127.0.0.0/8 accept

	# Anti-lockout rule (allow SSH from current connection)
	[ -n "${SSH_ADDR+x}" ] && add_ip_rule input ip saddr "$SSH_ADDR" tcp -m \
		--dport ssh accept

	# Prevent host spoofing
	add_ip_rule input ip saddr "$INTRANET_ADDR" drop
	add_ip_rule forward ip saddr "$INTRANET_ADDR" drop
	add_ip_rule forward ip daddr "$INTRANET_ADDR" drop
	add_ip_rule output ip daddr "$INTRANET_ADDR" drop

	# Allow DHCP from intranet for faster renewals
	add_ip_rule input ip saddr "$INTRANET" udp sport bootps udp dport bootpc \
		accept

	# Allow mDNS to/from intranet for zeroconf
	add_ip_rule input ip saddr "$INTRANET" udp dport mdns accept
	add_ip_rule input ip daddr 224.0.0.251 udp dport mdns accept
	add_ip_rule output ip daddr "$INTRANET" udp dport mdns accept
	add_ip_rule output ip daddr 224.0.0.251 udp dport mdns accept

	# Allow ping to and from intranet
	add_ip_rule output ip protocol icmp ip saddr "$INTRANET" icmp type \
		echo-reply accept
	add_ip_rule input ip protocol icmp ip saddr "$INTRANET" icmp type \
		echo-request accept

	# Uncomment the lines below as needed to make services available
	# add_ip_rule input ip saddr "$INTRANET" tcp dport ssh accept # SSH
	# add_ip_rule input tcp dport ssh accept # SSH (DANGER)
	# add_ip_rule input ip saddr "$INTRANET" udp dport 59999 accept # MOSH
	# add_ip_rule input udp dport 59999 accept # MOSH (DANGER)
	# add_ip_rule input tcp dport http accept # HTTP
	# add_ip_rule input tcp dport https accept # HTTPS
	# add_ip_rule input udp dport https accept # HTTP/2
	# add_ip_rule input tcp dport 25565 accept # Minecraft
	# add_ip_rule input ip saddr "$INTRANET" -p tcp dport 8123 accept # Dynmap
	# add_ip_rule input tcp dport 8123 accept # Dynmap (DANGER)

	# Allow required services outbound
	add_ip_rule output tcp dport \{ http, https \} accept
	add_ip_rule output udp dport \{ domain, https, ntp \} accept
	user_confirm 'Allow BitTorrent?' add_bittorrent_rules
	user_confirm 'Does this computer use OpenVPN?' add_openvpn_rules

	# Workstation?
	user_confirm 'Is this machine a workstation?' add_workstation_rules

	# Set default policy for all chains to DROP
	add_ip_chain input \{ policy drop\; \}
	add_ip_chain forward \{ policy drop\; \}
	add_ip_chain output \{ policy drop\; \}

	# Also drop IPv6
	sudo nft add table ip6 filter
	add_ip6_chain input \{ type filter hook input priority 0\; policy drop\; \}
	add_ip6_chain forward \{ type filter hook forward priority 0\; \
		policy drop\; \}
			add_ip6_chain output \{ type filter hook output priority 0\; \
				policy drop\; \}

	# Show the result
	printf '\n\e[1;32m%s\e[0m\n\n' "NFT rules implemented:"
	sudo nft list ruleset | sed 's/^/  /'
	printf '\n'

	# Save to /etc/nftables.conf
	user_confirm 'Save to /etc/nftables.conf?' save_permanent_nftables

	# Start nftables at boot
	[ -x "$(command -v systemctl)" ] && user_confirm 'Start nftables at boot?' \
		'sudo systemctl enable nftables'
}

_pos_args=()
while [ "$#" -gt 0 ]; do
	case "$1" in
		'--help'|'-h') usage;;
		*) _pos_args+=("$1"); shift;;
	esac
done
main "${_pos_args[@]}"
